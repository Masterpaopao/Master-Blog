# 网络服务中间件

这次我们来学习下如何使用Memcached，Redis，Celery等网络中间件的技术。

## 一.Memcached

#### 1.概念与特点

Memcached其实就是一个优秀的缓存系统，能够让访问过的数据读取更快，提升效率。

缓存的由来是什么，其实就是web应用程序和数据库交互的过程中，如何让数据的流通速度更快，于是就提出了缓存的概念，这样一来已经访问过且频率高的数据能够通过访问提取，而不需要通过数据库。

如果不弄缓存，就会访问量增加，每秒处理请求增多，数据库服务器压力过大……等等一些列问题。

&nbsp;

所以加上缓存的概念之后，web应用程序、数据库和缓存的三方交互效果如下:

![image-20191121160041676](assets/image-20191121160041676.png)

我们现在要学习的Memcached就是这样的一个缓存系统，其实Redis也可以做缓存系统。

那么它的特点有哪些呢？

- 开源，协议简单，高效
- 速度快，内存存储，断电后会消失，不是数据持久性存硬盘
- 数据满了之后会通过LRU缓存淘汰的机制来删除

&nbsp;

#### 2.安装与使用

如果要使用Memcached缓存系统，我们需要一个虚拟机作为它的服务器。

我打开了CentOS 7的linux系统，并输入`yum install memcached`进行安装

然后我输入`which memcached`来确定它的位置，得出它在这儿：

![image-20191121161003159](assets/image-20191121161003159.png)

`/bin/memcached -p 11211 -m 128m -u root -vv`

启动memcached，设置端口为11211，内存最大为128M ,root用户登录，并用-vv打印帮助说明

![image-20191121161522885](assets/image-20191121161522885.png)

这样一来，memcached缓存系统已经成功地启动了。

&nbsp;

接下来我们学习下如何使用这个缓存系统来完成添加缓存和查找缓存的方法。

我们可以克隆下这个会话，然后开启memcached缓存系统的虚拟机ip为192.168.111.140

输入`telnet 192.168.111.140 11211`进行交互。

https://www.runoob.com/memcached/memcached-set-data.html

![image-20191121170749855](assets/image-20191121170749855.png)

格式已经很清楚了，输入`set keyname 0 60 10`

这是什么意思呢，我要输入一个kv键值对中的k，叫做keyname，然后我设置60秒过期，值为10个字节。

下一行我再输入`abcde12345`，你会收到一个STORED，这是命中成功的意思。

![image-20191121170950138](assets/image-20191121170950138.png)

然后你想要读取缓存中键对应的值，输入`get keyname`即可取出值。

![image-20191121171033448](assets/image-20191121171033448.png)

set与get便是memcached最简单实际的两个方法，代表添加和读取。

&nbsp;

#### 3.Python控制

我们来讲一讲如何用Python控制memcached，这才是重头戏。

https://pymemcache.readthedocs.io/en/master/

![image-20191121171932664](assets/image-20191121171932664.png)

这个是最简单暴力的教学，就是基础于上面的set与get的交互。

![image-20191121173112798](assets/image-20191121173112798.png)

毫无疑问的是，我们的python成功连上了缓存系统，并返回了`b'master'`的结果，整个过程不就是最简单的kv键值对的添加与查询吗？

那么我们就弄一个难一点的缓存数据，为了大大提高数据索引的速度，我们可以设置一个字典：

![image-20191121175515538](assets/image-20191121175515538.png)

为什么我们读取的时候又是decode()又是eval()呢？

因为我们读取缓存的时候，获得的是bytes类型的数据，我们需要decode()转换为正常的str，再通过eval()转换为它原本的数据类型，也就是字典。然后再访问键master的值就OK了。

&nbsp;

## 二.Redis

为什么不细讲memcached，只是带大家了解一下，就转到Redis呢？

我们知道，Redis也能用来做缓存系统，而且还是全世界都在用。

#### 1.缓存系统

相比较memcached来说，redis的可靠性明显大大提升。

Redis最大的特点就是使用单线程，具有优化的能力，所以性能只比memcached稍微落后点。

但它能做的事情却很强大，适合更多数据操作，方便网络传输，更重要的是能在硬盘持久化。

![image-20191121211112513](assets/image-20191121211112513.png)

所以我们写代码的方法还是差不多的，还是set与get：

![image-20191121212209478](assets/image-20191121212209478.png)

&nbsp;

#### 2.订阅系统

redis也能用来做订阅系统吗，是的，在软件架构中，发布-订阅是一种消息范式。

![image-20191121212809358](assets/image-20191121212809358.png)

现在我们来试试这个redis的订阅系统，我们先打开两个cmd，一起尝试：

![image-20191121213025591](assets/image-20191121213025591.png)

一边先填上订阅者的名字：`SUBSCRIBE master`

另一边则给master客户发布消息：`PUBLISH master 'python is good'`

![image-20191121213550864](assets/image-20191121213550864.png)

如果右侧再发一条呢？`PUBLISH master "java is good,too"`

![image-20191121213645466](assets/image-20191121213645466.png)

这个就是一个简单的订阅-发布的交互过程。

现在，我们来创建两个Shell，确保这两者之间能互相交互：

![image-20191121214026747](assets/image-20191121214026747.png)

c1，你可以理解为发布者对象，或者一个电台。而c2，就是订阅者，或者收听电台的人。

这跟上面的PUBLISH发布和SUBSCRIBE订阅的效果是一样的。

首先，c1先发布一两条消息：

![image-20191121214842177](assets/image-20191121214842177.png)

然后订阅者c2选择订阅c1：

![image-20191121214938374](assets/image-20191121214938374.png)

订阅成功以后，遍历订阅后的消息成果：

![image-20191121215117439](assets/image-20191121215117439.png)

很显然是没有收到过往的订阅邮件，因为你必须要订阅后才能收到最新的邮件，过去的邮件是收不到的，所以这个时候，电台再发布一条新的消息，右边就自然而然的收到了：

![image-20191121215239676](assets/image-20191121215239676.png)

这是因为`s2.listen()`属于生成器类型，并不会遍历后结束，反而在原地等待新的消息并遍历出来。

&nbsp;

#### 3.订阅程序

现在，我们通过shell摸清楚了redis的发布-订阅的基本使用方法，我们可以开始写程序了。

```
发布：PUBLISH
c = redis.StrictRedis()
c.publish("name","message")
------
订阅：SUBSCRIBE
c = redis.Redis()
s = c.pubsub()
s.subscribe("name")
s.listen()
```

首先我们先来开发一下发布者的py文件，创建redis_pub.py，根据上面的指引，进行开发：

![image-20191121221850012](assets/image-20191121221850012.png)

是不是很简单，while True弄一个无限循环就可以了。

现在再来看看订阅者的py文件，创建redis_sub.py，接收消息如下：

![image-20191121222503894](assets/image-20191121222503894.png)

也是很简单的编写方法，基于上面的方法总结里面。

现在我要分别运行这两个程序，发布者在vscode，订阅者在shell：

![image-20191121222612470](assets/image-20191121222612470.png)

很明显，做得非常成功！但是问题来了，这样的消息明显效果不好，为什么不优化成更通俗的呢？

![image-20191121224411473](assets/image-20191121224411473.png)

现在订阅者收到的消息是这个样子的：

![image-20191121224344892](assets/image-20191121224344892.png)

当然了，一个用户也不可能只订阅一个频道，也是可以的，你可以全部进行订阅，只需要略改代码：

![image-20191121224821534](assets/image-20191121224821534.png)

&nbsp;

## 三.RabbitMQ

RabbitMQ是一款企业级消息系统的软件，被广泛使用。

#### 1.概念速讲

RabbitMQ是部署最广泛的开源消息代理，在小型创业公司和中型企业里中最受欢迎。

先启动Service进行初始化，然后发送消息Message发送到消息代理Broker，成功之后发送已知的回应。

消息代理的应用到底是什么，你们可能还没整明白：

- 将消息路由到一个或多个目的地
- 将消息转换为替代表示
- 执行消息聚合，将消息分解为多个消息将其发送到目的其，然后将响应重新组合成一条消息以返回用户进行确认。

![image-20191122215620324](assets/image-20191122215620324.png)

看到了吗，这就是发布-订阅的互动模式，采用了AMQP协议模型，发布者先发布消息，进入到Exchange进行加工数据，再由route决定路由生成一个链接，然后加入队列，再发给订阅者。

&nbsp;

#### 2.Exchange原理

我们要思考，消息到底是怎么发出去的？

AMQP是一种可编程的协议，定义了三种实体对象：queues，exchanges，bindings

- queues：队列，存储信息，用于获取
- exchanges：消息中转站，包含多种类型
- bindings：消息转发规则，定义了route，也就是路由规定怎么连接到队列

那么我们现在先重点关注消息中转站，exchanges会怎么处理数据？

![image-20191122221324085](assets/image-20191122221324085.png)

有Direct exchange、Fanout exchange、Topic exchange、Headers exchange这四种属性。

https://blog.csdn.net/yzh_1346983557/article/details/90260774

https://blog.csdn.net/qq_25825923/article/details/94969261

![image-20191122221624242](assets/image-20191122221624242.png)

默认情况下肯定是Direct Exchange，属于经典的生产者-消费者模式。

routing key就是路由键的意思，在默认模式下，发布者与订阅者都需要绑定同一个路由键，发布者的消息才能顺利地到达订阅者那儿，供订阅者进行消费。

它的使用需求非常简单，就是一个领导，给不同的人分配不同的任务，就是这样的场景。

![image-20191122222708643](assets/image-20191122222708643.png)

&nbsp;

但是还需要注意第二种fanout exchange模式，这也是非常重要的，为啥？

因为fanout exchange是传递消息到每一个queue，忽略routing key，这是什么应用场景呢？

统一发布通知，球赛更新比分，重要事项推送提醒，分布式系统更新配置等等需求，都是fanout的模式。

是不是很像那些无穷无尽的骚扰邮件……

![image-20191122222648153](assets/image-20191122222648153.png)

&nbsp;

第三种的Topic Exchange就比较好理解了，这是根据规则匹配的queue来实现发布/订阅。

不知道你有没有经历过出省旅游，每当你进入一个新的省份时，你会收到相应省份的欢迎短信。

或者说，你在逛论坛之前设置了几个感兴趣的点，系统就会给你分配相应的推荐内容。

![image-20191122222744135](assets/image-20191122222744135.png)

&nbsp;

最后一种的Headers Exchange就比较复杂了，可能难以理解，因为这个规则是完全自定义的。

也就是说自己自定义匹配机制进行发送消息。

![image-20191122223015107](assets/image-20191122223015107.png)

&nbsp;

#### 3.安装配置

官网地址：www.rabbitmq.com

还需要准备一台虚拟机，我这儿准备的是CentOS 7。

